# Implement Seccomp in Kubernetes

<figure><img src="../.gitbook/assets/image (6) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Now that we have seen how to make use of seccomp profiles in Docker, let us see how to do the same in Kubernetes.&#x20;
* Before we start testing seccomp profiles in Kubernetes pods, let us see how Docker and Kubernetes use seccomp by default.&#x20;
* In the previous lecture, we learned that Docker blocks around 66 calls with its default profile. Well, there's a simple way to test this using an open-source container introspection tool called AMI Contained. This tool can be run as a Docker container and it provides information about the run-time used to create the container, its features, and most importantly, the syscalls that is blocked.&#x20;
* Let us run a container using the Docker run command without any additional flags like this.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* As you can see, 64 syscalls are blocked in this case owing to the fact that Docker uses the default seccomp profile.&#x20;
* We can also see that seccomp is running in mode two or the filtering mode. Now, let us use the same image, but this time run it as a Kubernetes pod.&#x20;
* Once the pod is created we can inspect the logs to pull the same information. You'll notice that this time the results are quite different when compared to that of Docker.&#x20;
* When the container is run as a pod within Kubernetes the number of syscall blocks is only 21 and the status of seccomp is disabled. This is because Kubernetes, as of this recording and version 1.20, does not implement Seccop by default.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* In order to implement seccomp, let us use the same image, but this time let us use a pod definition file.&#x20;
* Now, to apply a seccomp profile, we have to add the seccomp profile field in the security context section of the pod or the container manifest, like this.&#x20;
* To use the default profile for Docker, which is the runtime used for this Kubernetes cluster, we can specify the type to RuntimeDefault.&#x20;
* In this example, we have added the seccomp profile directly under the security context section of the pod rather than the container. When we run a container inside a Kubernetes pod, there's a possibility that the process running inside the container can escalate its privileges, which may allow it to have more privileges than its span process.&#x20;
* To prevent this from happening, it's a good idea to add a lot of privilege escalation to false under the security context for the container. This will ensure that the application will only run with the bare minimum privileges it needs to function properly.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Once the pod is created using kubectl create or apply, we can see that this time seccomp is used and we have more syscalls blocked as expected.

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* We can also specifically use the unconfined seccomp profile. However, as we saw earlier, Kubernetes does this by default anyway.

<figure><img src="../.gitbook/assets/image (5) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Just like we did with the Docker example, we can also make use of custom seccomp profiles. For this example, let us make use of a different image.&#x20;
* This time let us create a new pod with the Ubuntu image. The container will print a message and sleep for 100 seconds.&#x20;
* To use the custom seccomp profile set the type to localhost. We can then make use of the local host profiles field, which is the part of a pre-configured profile on the node.&#x20;
* One important thing to note here is that this part must be relative to the default seccomp profile location, which is var/lib/kubelet/seccomp by default.

<figure><img src="../.gitbook/assets/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* To do this, first create a directory called profiles under the default seccomp profile path, then inside this directory, create an audit profile which will log all syscalls generated by the process running in the container.&#x20;
* To do this, just add the default action set to SCMP ACT\_LOG. Now we can update the local host profile to profiles/audit.json, which again is the relative part from var/lib/kubelet/seccomp.

<figure><img src="../.gitbook/assets/image (7) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Once the pod is created, the syscalls generated by the process in the Ubuntu container will be logged in the /var/log/syslog file. From these logs, we can see that the simple command run inside the container has generated many syscall calls.&#x20;
* As you can see, it logs the IDs of the processes that generated the syscall, the user ID, the group ID, and the syscall itself as a number, but what are these numbers and how do we identify what syscall is it associated with?

<figure><img src="../.gitbook/assets/image (8) (1) (1).png" alt=""><figcaption></figcaption></figure>

* One way to map the syscall numbers to the actual syscall name is to check the /usr/include/asm/unitstd\_64.h file in Ubuntu. After analyzing the audit logs, we can now map all the syscalls made by the container in our pod. The table here shows some of the syscalls.

<figure><img src="../.gitbook/assets/image (9) (1) (1).png" alt=""><figcaption></figcaption></figure>

* We can also make use of the Tracee tool that we saw in one of the previous lectures. This can be used to analyze the syscalls made by this new container.&#x20;
* Here we are running the Tracee container with the command --trace container=new. Which will then provide the syscalls made by all the new containers on the host.&#x20;
* We can then look for the syscalls just made by the test audit pod.

<figure><img src="../.gitbook/assets/image (10) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Next, let's make use of another profile, one which will reject all syscalls by default. To do this, let us create another profile by the name of violation.json. In this file, set the default action to SCMP\_ACT\_ERRNO, which will reject any syscalls generated by the container.&#x20;
* Then specify the violation.json profile to be used under the pod security contexts like this.

<figure><img src="../.gitbook/assets/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

* Once the pod has been created, we will find that the status of the pod would remain at container cannot run. This is expected because the profile that we just used blocks also syscalls by default.
* While this is extremely secure, it is quite useless as we cannot run anything meaningful with this profile.

<figure><img src="../.gitbook/assets/image (12) (1) (1).png" alt=""><figcaption></figcaption></figure>

* After analyzing all the syscalls made by our application by inspecting the audit logs generated by the audit profile or by making use of third-party tools such as Tracee, we can now craft custom profile that can be used for our application.
* To make use of a custom profile, place the json file inside the same directory and update the local host profile in the pod definition file.
* If the profile was created correctly, allowing all system calls required by the application, the pod should start successfully. The key to using seccomp effectively is to correctly determine all the syscalls that your application need and block everything else.
* This can be a tedious task and completely depends on the type of application. However, once an effective profile is created and used, it can certainly improve the isolation of our pods and help secure the Kubernetes cluster.

<figure><img src="../.gitbook/assets/image (13) (1).png" alt=""><figcaption></figcaption></figure>

* From an exam point of view, we do not anticipate that you'll be asked to create a custom seccomp profile from scratch. However, you may be asked to copy an existing seccomp profile to the default seccomp location on all nodes of the Kubernetes cluster.&#x20;
* Then you may have to use it to create pods. You will find all seccomp related information within the Kubernetes documentation here.
